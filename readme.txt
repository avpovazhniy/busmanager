Краткое описание:

Так как диспетчер не должен разбирать содержимое ответов от модулей,
эта функция возлагается на пользователя диспетчера, функция диспетчера
состоит в том чтобы передать данные от пользователя к модулям и обратно,
предоставив пользователю удобный интерфейс для взаимодействия, то я решил
остановится на следующей схеме:
Диспетчер состоит из двух классов: Bus и Module, экземпляр класса Bus
содержит в себе объекты класса Module в соответствии с конфигурацией контроллера.
При создании объекта Bus необходимо указать конфигурационный файл:
	Bus bus("config.ini");
После этого внутри будут находится модули в соответствии с заданой конфигурацией,
в виде ассоциативного контейнера std::unordered_map <Адрес_модуля, Модуль>. Это позволит
иметь асимптотику поиска модуля при разборе ответной телеграммы контроллера O(1).
Данные для модулей должны приходить в виде контейнеров std::vector, содержащих в себе
одно или несколько сообщений. Это позволит упростить пользователю передачу потоковых
данных, не разбивая их самому на блоки, это сделает диспетчер, в то же время остаётся
возможность передавать одно сообщение за раз.

Пример задания данных для передачи единичному модулю:

	Module* module = bus.GetModuleByAddr(Адрес_модуля);
	if (module)
	{
		module->SetData(&Вектор_с_данными);
	}

Пример задания данных для передачи всем модулям контроллера:

	std::unordered_map <Адрес_модуля, Вектор_данных_модуля > V;
	for (auto it = V.begin(); it != V.end(); ++it)
	{
		Module* module = bus.GetModuleByAddr(V.first);
		module->SetData(&V.second);
	}

Передача данных по шине производится вызовом метода SendData() класса Bus. Ответы
должны вернуться в те же самые вектора переданые диспетчеру извне.

Что не сделано на текущий момент:

Не реализован парсер конфигурационного файла, инициализация производится "вручную"
внутри конструктора класса Bus.

Не сделан разбор ответной телеграммы от контроллера и копирование этих данных назад к пользователю
в переданные им вектора.

Не сделана обработка реакции на не-инкремент счётчика (т.е. обработка ситуации что какой-то модуль вышел из строя)
Предполагаю сделать следующим образом: сообщение для этого модуля отправлять ещё раз, до исчерпания всех данных всех
модулей. После того как всё что можно было успешно передать - передалось, передавать ошибочный код возврата из Bus::SendData()
И пользователь сам сможет определить с какими модулями проблема, там всё для этого есть, смещение данных, остаток данных,
для проблемных модулей счётчик можно обнулить.